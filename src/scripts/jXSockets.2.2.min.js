var Queue = function (e) { var t = this; this.settings = e; this.length = 0; this.items = []; this.timer = 0; t.items.push = function (n) { t.length++; if (t.length === 1) t.timer = setInterval(function () { var n = t.items.slice(0, 1); if (n.length === 1) { t.items.remove(n[0]); e.dequeued.call(this, n[0]) } }, e.interval); return Array.prototype.push.call(this, n) }; t.items.remove = function () { var n, r = arguments, i = r.length, s; while (i && this.length) { n = r[--i]; while ((s = this.indexOf(n)) != -1) { this.splice(s, 1) } } t.length--; if (t.length === 0) { e.clean.call(this); clearInterval(t.timer) } return this }; this.enqueue = function (e) { t.items.push({ k: t.length, v: e }) }; this.cleanUp = function () { clearInterval(t.timer); t.items = [] }; this.Empty = function () { t.items.forEach(function (n) { e.dequeued.call(this, n); t.items.remove(n) }, this); clearInterval(t.timer) } }; var Subscriptions = function () { var e = []; this.add = function (n, r, i) { n = n.toLowerCase(); var s = this.get(n); if (s === null) { var o = new t(n); o.addCallback(r, i); e.push(o); return 1 } s.addCallback(r, i); return s.Callbacks.length }; this.get = function (t) { t = t.toLowerCase(); for (var n = 0; n < e.length; n++) { if (e[n].Name === t) return e[n] } return null }; this.getAll = function () { return e }; this.remove = function (t, n) { t = t.toLowerCase(); for (var r = 0; r < e.length; r++) { if (e[r].Name === t) { if (n === undefined) { e.splice(r, 1) } else { e[r].Callbacks.splice(n - 1, 1); if (e[r].Callbacks.length === 0) e.splice(r, 1) } return true } } return false }; this.fire = function (t, n, r, i) { t = t.toLowerCase(); for (var s = 0; s < e.length; s++) { if (e[s].Name === t) { if (i === undefined) { e[s].fireCallbacks(n, r) } else { e[s].fireCallback(n, r, i) } } } }; var t = function (e) { this.Name = e; this.Callbacks = []; this.addCallback = function (e, t) { this.Callbacks.push(new n(e, t)) }; this.fireCallback = function (e, t, n) { this.Callbacks[n - 1].fn(e); if (typeof this.Callbacks[n - 1].state === "object") { if (typeof this.Callbacks[n - 1].state.options !== "undefined" && typeof this.Callbacks[n - 1].state.options.counter !== "undefined") { this.Callbacks[n - 1].state.options.counter.messages--; if (this.Callbacks[n - 1].state.options.counter.messages === 0) { if (typeof this.Callbacks[n - 1].state.options.counter.completed === "function") { this.Callbacks[n - 1].state.options.counter.completed() } } } } if (t && typeof t === "function") { t() } }; this.fireCallbacks = function (e, t) { for (var n = 0; n < this.Callbacks.length; n++) { this.fireCallback(e, t, n + 1) } } }; var n = function (e, t) { this.fn = e; this.state = t }; return this }; (function () { "use strict"; var e = { Queue: true, Delay: 30, Events: { onError: "xsockets.onerror", open: "xsockets.xnode.open", close: "close", storage: { set: "xsockets.storage.set", get: "xsockets.storage.get", getAll: "xsockets.storage.getall", remove: "xsockets.storage.remove" }, serverstatus: { status: "xsockets.server.status" }, onBlob: "blob", connection: { getallclients: "xsockets.getallclients", onclientconnect: "xsockets.onclientconnect", onclientdisconnect: "xsockets.onclientdisconnect", disconnect: "xsockets.disconnect" } }, Utils: { getParameterByName: function (e) { e = e.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]"); var t = "[\\?&]" + e + "=([^&#]*)"; var n = new RegExp(t); var r = n.exec(window.location.search); if (r == null) return ""; else return decodeURIComponent(r[1].replace(/\+/g, " ")) }, extend: function (e, t) { if (arguments.length > 2) { for (var n = 1; n < arguments.length; n++) { extend(e, arguments[n]) } } else { for (var r in t) { e[r] = t[r] } } return e }, guid: function (e, t) { for (t = e = ""; e++ < 36; t += e * 51 & 52 ? (e ^ 15 ? 8 ^ Math.random() * (e ^ 20 ? 16 : 4) : 4).toString(16) : "-"); return t } }, WebSocket: function (t, n, r) { var i = null; var s = this; var o = new Subscriptions; var u = XSockets.Utils.extend({ queue: e.Queue, apikey: null, parameters: {} }, r); this.handler = n; this.channel = {}; if (u.queue) { var a = { dequeued: function (e) { c(e.v.event, e.v.json, e.v.callback) }, clean: function () { }, interval: e.Delay }; this.Queue = new Queue(a) } var f = { subscribe: "xsockets.subscribe", unsubscribe: "xsockets.unsubscribe", getSubscriptions: "xsockets.getsubscriptions", getAllSubscriptions: "xsockets.getallsubscriptions" }; var l = function (e) { var t = "?"; for (var n in e) { t += n + "=" + encodeURIComponent(e[n]) + "&" } t = t.slice(0, t.length - 1); return t }; this.close = function (e) { this.trigger(XSockets.Events.connection.disconnect, {}, e) }; this.getSubscriptions = function () { return o.getAll() }; this.bind = function (e, t, n, r) { var u = { options: n, ready: i.readyState }; if (u.ready === 1) { s.trigger(new XSockets.Message(f.subscribe, { Event: e })) } o.add(e, t, u); if (r && typeof r === "function") { r() } }; this.unbind = function (e, t) { if (o.remove(e)) { s.trigger(new XSockets.Message(f.unsubscribe, { Event: e })) } if (t && typeof t === "function") { t() } }; this.many = function (e, t, n, r) { s.bind(e, n, XSockets.Utils.extend({ counter: { messages: t, completed: function () { s.unbind(e) } } }, r)) }; this.one = function (e, t, n) { s.bind(e, t, XSockets.Utils.extend({ counter: { messages: 1, completed: function () { s.unbind(e) } } }, n)) }; this.trigger = function (e, t, n) { if (u.queue) { s.Queue.enqueue({ event: e, json: t, callback: n }) } else { c(e, t, n) } }; var c = function (e, t, n) { if (typeof e !== "object") { e = e.toLowerCase(); var r = XSockets.Message(e, t); d(r.toString()); if (n && typeof n === "function") { n() } } else { d(e.toString()); if (t && typeof t === "function") { t() } } }; this.send = function (e) { i.send(e) }; var h = function (e, t) { if (o.get(e) === null) { return } if (typeof t === "string") { t = JSON.parse(t) } o.fire(e, t, function () { }) }; var p = function (e) { var t = null; if (typeof e.data === "string") { var n = JSON.parse(e.data); t = n.event; h(t, n.data) } else { h(XSockets.Events.onBlob, e.data) } }; var d = function (e) { i.send(e) }; Array.prototype.removeItem = function (e) { for (var t = 0; t < this.length; t++) { if (escape(this[t]).match(escape(e.trim()))) { this.splice(t, 1); break } } return this }; if ("WebSocket" in window) { var v = window.localStorage.getItem("XSocketsClientStorageGuid" + n) !== null ? window.localStorage.getItem("XSocketsClientStorageGuid" + n) : null; if (u.apikey !== null) { u.parameters["apikey"] = u.apikey } if (v !== null) { u.parameters["XSocketsClientStorageGuid"] = v } t = t + l(u.parameters); i = new window.WebSocket(t, n) } if (i !== null) { s.bind(e.Events.open, function (e) { window.localStorage.setItem("XSocketsClientStorageGuid" + n, e.StorageGuid); var t = o.getAll(); for (var r = 0; r < t.length; r++) { for (var i = 0; i < t[r].Callbacks.length; i++) { if (t[r].Callbacks[i].ready !== 1) { s.trigger(new XSockets.Message(f.subscribe, { Event: t[r].Name })) } } } }, { subscribe: false }); i.onclose = function (e) { s.Queue.cleanUp(); h("close", e) }; i.onopen = function (e) { h("open", e) }; i.onmessage = function (e) { p(e) } } return { close: s.close, bind: s.bind, unbind: s.unbind, one: s.one, many: s.many, on: s.bind, off: s.unbind, trigger: s.trigger, triggerBinary: s.send, send: s.send, channel: s.channel, subscribe: s.bind, publish: s.trigger, subscriptions: s.getSubscriptions } }, Channel: function () { var t = function (t, n, r) { var i = e.Utils.guid(); var s = t + "/" + i; var o = new XSockets.WebSocket(s, n, r); o.channel = { Id: i, args: [s, n, r] }; return o }; var n = function (e) { return new XSockets.WebSocket(e.args[0], e.args[1], e.args[2]) }; return { Create: t, Connect: n } }(), Message: function (e, t) { var n = { event: e, data: JSON.stringify(t) }; this.JSON = function () { return n }(); this.toString = function () { return JSON.stringify(n) }; return this } }; if (!window.jXSockets) { window.jXSockets = e } if (!window.XSockets) { window.XSockets = e } })()